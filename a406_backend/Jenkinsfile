pipeline {
    agent any

    environment {
        GIT_BRANCH = 'main'
        GITHUB_REPO_URL = 'https://github.com/hanjaegyeong/Fillit.git'
        DOCKER_IMAGE_NAME = 'fillit'
        DOCKER_CONTAINER_NAME = 'fillit-container'
        DOCKER_PORT = '8081'

        /* Gradle 캐시 보존을 위한 사용자 홈(워크스페이스 내) */
        GRADLE_USER_HOME = "${WORKSPACE}/.gradle"
    }

    stages {

        /* 1. GitHub에서 코드 체크아웃 */
        stage('Checkout') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'github-credentials', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
                        git branch: "${GIT_BRANCH}",
                            credentialsId: 'github-credentials',
                            url: "${GITHUB_REPO_URL}"
                    }
                }
            }
        }

        /* 2. Gradle 빌드 */
        stage('Build') {
            steps {
                dir('a406_backend') {
                    sh '''
                        set -eu
                        mkdir -p "$GRADLE_USER_HOME"

                        # Gradle 빌드 튜닝
                        cat > gradle.properties <<'EOF'
                            org.gradle.daemon=true
                            org.gradle.caching=true
                            org.gradle.parallel=true
                            org.gradle.jvmargs=-Xmx1g -XX:MaxMetaspaceSize=512m -Dfile.encoding=UTF-8
                            EOF

                        chmod +x ./gradlew
                        ./gradlew clean build -x test \
                            -Dspring.redis.host=redis
                    '''
                }
                sh '''
                    # a406_backend 디렉토리 명시 위해 작성
                    cp a406_backend/build/libs/*.jar a406_backend/app.jar
                '''
            }
        }

        /* 3. Docker 이미지 빌드 & 푸시 (빌드번호+커밋SHA로 고유 태그) */
        stage('Build & Push Docker Image') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'docker-hub-credentials', usernameVariable: 'DOCKER_HUB_USER', passwordVariable: 'DOCKER_HUB_PASS')]) {
                    sh '''
                        set -eu

                        # Docker Hub 로그인
                        echo "$DOCKER_HUB_PASS" | docker login -u "$DOCKER_HUB_USER" --password-stdin

                        IMAGE="jaegyeong223/fillit:${BUILD_NUMBER}-$(git rev-parse --short=7 HEAD)"

                        echo "▶ Building single-arch image for ARM64 cluster (no buildx): $IMAGE"
                        docker build -t "$IMAGE" -f a406_backend/Dockerfile a406_backend
                        docker push "$IMAGE"

                        echo "FILLIT_IMAGE=$IMAGE" > /tmp/fillit-image.env
                    '''
                }
            }
        }

        /* 4. Redis 배포 */
        stage('Deploy Redis to Kubernetes') {
            steps {
                echo 'Deploying Redis to Kubernetes...'
                sh '''
                    set -eu
                    kubectl apply -f a406_backend/k8s/redis.yaml
                '''
            }
        }

        /* 5. RabbitMQ 배포 */
        stage('Deploy RabbitMQ to Kubernetes') {
            steps {
                echo 'Deploying RabbitMQ to Kubernetes...'
                sh '''
                    set -eu
                    kubectl apply -f a406_backend/k8s/rabbitmq-deploy.yaml
                    kubectl apply -f a406_backend/k8s/rabbitmq-service.yaml
                    kubectl rollout status deployment/rabbitmq --timeout=5m
                '''
            }
        }

        /* 6. 애플리케이션 배포 */
        stage('Deploy Application to Kubernetes') {
            steps {
                script {
                    echo 'Deploying application to Kubernetes...'
                    withCredentials([file(credentialsId: 'fillit-secret-file', variable: 'ENVF')]) {
                        sh '''
                            set -eu

                            # Secret/ConfigMap 생성
                            kubectl create secret generic fillit-secret --from-env-file="$ENVF" --dry-run=client -o yaml | kubectl apply -f -
                            kubectl create configmap fillit-config --from-env-file=a406_backend/k8s/fillit-config.env --dry-run=client -o yaml | kubectl apply -f -

                            # envsubst 치환
                            export $(cat /tmp/fillit-image.env | xargs)
                            envsubst < a406_backend/k8s/fillit-deployment.yaml.template | kubectl apply -f -

                            # 배포 완료 대기
                            kubectl rollout status deployment/fillit-deployment --timeout=5m

                            # 실제 적용된 이미지 확인
                            echo -n "[INFO] Deployed image: "
                            kubectl get deploy fillit-deployment -o jsonpath='{.spec.template.spec.containers[0].image}'; echo
                        '''
                    }
                }
            }
        }

        /* 7. HPA 설정 */
        stage('Configure HPA') {
            steps {
                sh '''
                    set -eu
                    kubectl autoscale deployment fillit-deployment --cpu-percent=50 --min=1 --max=10 || true
                    kubectl get hpa
                '''
            }
        }

        /* 8. 모니터링 리소스 적용 */
        stage('Deploy Monitoring Resources') {
            steps {
                sh '''
                    set -eu
                    kubectl get ns monitoring >/dev/null 2>&1 || kubectl create ns monitoring

                    kubectl apply -f a406_backend/k8s/prometheus-configmap.yaml -n monitoring
                    kubectl apply -f a406_backend/k8s/prometheus.yaml -n monitoring
                    kubectl apply -f a406_backend/k8s/grafana-ingress.yaml
                    kubectl apply -f a406_backend/k8s/fillit-podmonitor.yaml
                '''
            }
        }

        /* 9. 빌드/이미지 캐시 정리 */
        stage('Cleanup') {
            steps {
                sh '''
                    set +e
                    # 사용 안 하는 컨테이너/이미지만 정리
                    docker container prune -f
                    docker image prune -f
                    exit 0
                '''
            }
        }
    }
}
